<html><head><title>Documenta&ccedil;&atilde;o projeto EAD@Cel 25/01/2011</title><style type="text/css">ol{margin:0;padding:0}p{margin:0}.c34{vertical-align:top;width:63.75pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c32{vertical-align:top;width:50.25pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c4{vertical-align:top;width:86.25pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c25{vertical-align:top;width:51.0pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c38{vertical-align:top;width:63.0pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c11{padding-left:0pt;line-height:1.5;text-align:justify;direction:ltr;margin-left:72.0pt;padding-bottom:10.0pt}.c26{vertical-align:top;width:98.25pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c18{vertical-align:top;width:54.75pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c2{vertical-align:top;width:93.6pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c30{vertical-align:top;width:84.75pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c17{vertical-align:top;width:55.5pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c24{vertical-align:top;width:64.5pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c10{vertical-align:top;width:67.0pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c23{vertical-align:top;width:62.25pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c21{vertical-align:top;width:81.75pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c28{vertical-align:top;width:66.75pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c5{vertical-align:top;width:67.125pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c16{vertical-align:top;width:51.75pt;border-style:solid;border-color:#000000;border-width:1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt}.c0{line-height:1.5;text-indent:0pt;text-align:justify;direction:ltr;padding-bottom:10.0pt}.c12{padding-left:0pt;line-height:1.5;text-align:justify;direction:ltr;margin-left:72.0pt}.c35{line-height:1.5;text-indent:0pt;text-align:justify;direction:ltr;margin-left:72.0pt}.c8{padding-left:0pt;line-height:1.5;text-align:justify;direction:ltr;margin-left:36.0pt}.c29{line-height:1.0;text-indent:0pt;text-align:justify;direction:ltr}.c6{color:#000099;font-size:11pt;font-family:Arial;text-decoration:underline}.c3{line-height:1.15;text-indent:0pt;text-align:justify;direction:ltr}.c1{color:#000000;font-size:11pt;font-family:Arial}.c15{color:#000000;font-size:11pt;font-family:Consolas}.c22{color:#000000;font-size:12pt;font-family:Arial}.c13{color:#000000;font-size:9pt;font-family:Arial}.c36{color:#000000;font-size:11pt;font-family:Courier New}.c7{font-style:italic;font-weight:bold}.c37{list-style-type:circle}.c20{padding-bottom:10.0pt}.c31{text-decoration:underline}.c9{list-style-type:disc}.c27{border-collapse:collapse}.c19{font-weight:bold}.c14{height:0pt}.c33{background-color:#ffffff}body{color:#000000;font-size:11pt;font-family:Arial}h1{color:#000000;font-size:24pt;margin:0;font-family:Arial;font-weight:bold;padding:0}h2{color:#000000;font-size:18pt;margin:0;font-family:Arial;font-weight:bold;padding:0}h3{color:#000000;font-size:14pt;margin:0;font-family:Arial;font-weight:bold;padding:0}h4{color:#000000;font-size:12pt;margin:0;font-family:Arial;font-weight:bold;padding:0}h5{color:#000000;font-size:11pt;margin:0;font-family:Arial;font-weight:bold;padding:0}h6{color:#000000;font-size:10pt;margin:0;font-family:Arial;font-weight:bold;padding:0}</style></head><body class="c33"><p class="c0"><span class="c1">Documenta&ccedil;&atilde;o Projeto EAD@Cel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25/01/2011</span></p><ol class="c9"><li class="c8" value="1"><span class="c1">Andr&eacute; Schulz</span></li><li class="c8"><span class="c1">Giancarlo Rampanelli</span></li></ol><p class="c0"><span class="c1">&nbsp;</span></p><p class="c0"><span class="c1">Janeiro de 2011</span></p><p class="c0"><span class="c1">&nbsp;</span></p><p class="c0"><span class="c1">&Iacute;NDICE:</span></p><ol class="c9"><li class="c8" value="1"><span class="c6"><a href="#id.uharv5-ijnx5g">Objetivos do projeto</a></span></li><li class="c8"><span class="c6"><a href="#id.4hwfam-m6w1u0">Sobre esta documenta&ccedil;&atilde;o</a></span></li><li class="c8"><span class="c6"><a href="#id.75ezh6-fqgqlx">Conceitos b&aacute;sicos:</a></span></li></ol><ol class="c37"><li class="c12" value="1"><span class="c6"><a href="#id.xk156z-mbvz5w">Android</a></span></li><li class="c12"><span class="c6"><a href="#id.e7nen0-arwjzr">Comunica&ccedil;&atilde;o por v&iacute;deo</a></span></li><li class="c12"><span class="c6"><a href="#id.adpwck-skgseb">Programa&ccedil;&atilde;o de aplicativos de v&iacute;deo no android</a></span></li></ol><ol class="c9"><li class="c8" value="4"><span class="c6"><a href="#id.jt7185-r3755i">Implementa&ccedil;&atilde;o:</a></span></li></ol><ol class="c37"><li class="c12" value="1"><span class="c6"><a href="#id.ins8g5-vu9igv">Quest&otilde;es de implementa&ccedil;&atilde;o</a></span></li><li class="c12"><span class="c6"><a href="#id.qp9rgs-nbrql6">Documenta&ccedil;&atilde;o da implementa&ccedil;&atilde;o do EAD@Cel</a></span></li><li class="c12"><span class="c6"><a href="#id.jecxv8lmv592">Diagramas de sequ&ecirc;ncia</a></span></li><li class="c12"><span class="c6"><a href="#kix.q0ykdf-dapsey">Estrurura de diret&oacute;rios e arquivos importantes</a></span></li><li class="c12"><span class="c6"><a href="#id.jlosd-n06163">Diagramas de classes java</a></span></li></ol><ol class="c9"><li class="c8" value="5"><span class="c6"><a href="#id.9zbuof-nl5y9j">Configura&ccedil;&atilde;o do ambiente que utilizamos:</a></span></li></ol><ol class="c37"><li class="c12" value="1"><span class="c6"><a href="#id.xiaalc-e7eqf">Configura&ccedil;&atilde;o de rede</a></span></li><li class="c12"><span class="c6"><a href="#id.tjeqqv-dz9w8j">Instala&ccedil;&atilde;o e configura&ccedil;&atilde;o das ferramentas</a></span></li><li class="c12"><span class="c6"><a href="#id.i3x89c-3rr6l">Processo de compila&ccedil;&atilde;o</a></span></li></ol><ol class="c9"><li class="c8" value="6"><span class="c6"><a href="#id.s9nq3v-pivp8c">Testes de desempenho</a></span></li></ol><ol class="c37"><li class="c12" value="1"><span class="c6"><a href="#id.v7lzl3-mxwcz5">Teste 1: Transmitindo com o Samsung e recebendo com o Milestone</a></span></li><li class="c11"><span class="c6"><a href="#id.7irmnt-gn2i7i">Teste 2: Transmitindo com o Milestone e recebendo com o Samsung</a></span></li><li class="c11"><span class="c6"><a href="#kix.pwxi02-f5u4ay">Teste 3: Aumentando a taxa de frames</a></span></li><li class="c11"><span class="c6"><a href="#id.8xnd88-wyry53">An&aacute;lise dos resultados dos testes</a></span></li></ol><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.uharv5-ijnx5g"></a><p class="c0"><span class="c7 c22">Objetivos do projeto:</span></p><p class="c0"><span class="c1">Transmiss&atilde;o e recep&ccedil;&atilde;o de v&iacute;deo e &aacute;udio em tempo real atrav&eacute;s de celulares com sistema operacional Android, para fins de ensino a dist&acirc;ncia e integra&ccedil;&atilde;o com o sistema IVA de v&iacute;deo-confer&ecirc;ncia (mais detalhes desse sistema em </span><span class="c6"><a href="http://www.google.com/url?q=http%3A%2F%2Fwww.inf.ufrgs.br%2Fprav%2Fprojetos_sicremaq.html&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNFO3-A3Fk3uK2JFKTUybJvr1b3wLw">http://www.inf.ufrgs.br/prav/projetos_sicremaq.html</a></span><span class="c1">), mas podendo estender-se para outros fins e integrar-se com outros sistemas. </span></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.4hwfam-m6w1u0"></a><p class="c0"><span class="c22 c7">Sobre esta documenta&ccedil;&atilde;o:</span></p><p class="c0"><span class="c1">Nesta data (25/01/2011) estamos fechando uma vers&atilde;o com as funcionalidades b&aacute;sicas (envio e recep&ccedil;&atilde;o de v&iacute;deo em tempo real). Ainda n&atilde;o deve ser usada por usu&aacute;rios finais, pois h&aacute; alguns par&acirc;metros &ldquo;hard-coded&rdquo;, a interface est&aacute; em desenvolvimento, n&atilde;o h&aacute; uma verifica&ccedil;&atilde;o de par&acirc;metros suportados pelos diferentes aparelhos nem foram realizados testes suficientes e otimiza&ccedil;&otilde;es poss&iacute;veis. Serve como base para o desenvolvimento de vers&otilde;es que se escolher seguir dependendo do escopo do projeto.</span></p><p class="c0"><span class="c1">Esta documenta&ccedil;&atilde;o apresenta, inicialmente, um cap&iacute;tulo com </span><span class="c6"><a href="#id.75ezh6-fqgqlx">conceitos b&aacute;sicos </a></span><span class="c1">que s&atilde;o necess&aacute;rios para um melhor entendimento do projeto por todas as pessoas envolvidas, sobre:</span></p><ol class="c9"><li class="c8" value="1"><span class="c6"><a href="#id.xk156z-mbvz5w">Android</a></span></li><li class="c8"><span class="c6"><a href="#id.e7nen0-arwjzr">Comunica&ccedil;&atilde;o por v&iacute;deo</a></span></li><li class="c8 c20"><span class="c6"><a href="#id.adpwck-skgseb">Programa&ccedil;&atilde;o de aplicativos de v&iacute;deo no android</a></span></li></ol><p class="c0"><span class="c1">Em seguida, &eacute; documentada, em resumo, a </span><span class="c6"><a href="#id.jt7185-r3755i">implementa&ccedil;&atilde;o da vers&atilde;o atual do EAD@Cel</a></span><span class="c1">, dividida em Captura, Codifica&ccedil;&atilde;o, Envio, Recep&ccedil;&atilde;o, Decodifica&ccedil;&atilde;o e Renderiza&ccedil;&atilde;o de &aacute;udio/v&iacute;deo, fornecendo uma vis&atilde;o geral do c&oacute;digo do aplicativo e alguns detalhes e quest&otilde;es de implementa&ccedil;&atilde;o cuja documenta&ccedil;&atilde;o &eacute; importante, al&eacute;m de uma explica&ccedil;&atilde;o da estrutura de diret&oacute;rios utilizada no projeto e uma breve documenta&ccedil;&atilde;o de alguns arquivos importantes.</span></p><p class="c0"><span class="c1">Depois, apresentamos um </span><span class="c6"><a href="#id.9zbuof-nl5y9j">guia para configura&ccedil;&atilde;o do ambiente de programa&ccedil;&atilde;o</a></span><span class="c1">.</span></p><p class="c0"><span class="c1">Ao final, mostramos alguns </span><span class="c6"><a href="#id.s9nq3v-pivp8c">testes realizados</a></span><span class="c1"> e uma explica&ccedil;&atilde;o de como fizemos para chegar nos resultados obtidos.</span></p><p class="c0"><span class="c1">Logo, esta documenta&ccedil;&atilde;o serve para organizar de forma resumida o que foi feito desde o in&iacute;cio da implementa&ccedil;&atilde;o do EAD@Cel no Android at&eacute; a data atual, facilitando o entendimento dele por parte de todos os envolvidos no projeto.</span></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.75ezh6-fqgqlx"></a><p class="c0"><span class="c22 c19">1 CONCEITOS B&Aacute;SICOS:</span></p><p class="c0"><a href="#" name="id.xk156z-mbvz5w"></a><span class="c1 c7">1.1 Android: </span></p><p class="c0"><span class="c1">Android &eacute; um sistema operacional de c&oacute;digo aberto para dispositivos m&oacute;veis constru&iacute;do sobre uma vers&atilde;o modificada do kernel Linux. Aplicativos para Android s&atilde;o escritos com a linguagem de programa&ccedil;&atilde;o Java e rodam na m&aacute;quina virtual Dalvik. O desenvolvimento de aplicativos &eacute; feito com o kit de desenvolvimento de software para Android (Android SDK). (</span><span class="c6"><a href="#id.tjeqqv-dz9w8j">Nosso guia de instala&ccedil;&atilde;o</a></span><span class="c1">) Esse kit fornece diversas ferramentas &uacute;teis (como depuradores de c&oacute;digo, emuladores e APIs) al&eacute;m de oferecer plataformas que permitem a compila&ccedil;&atilde;o de aplicativos. O site oficial do android fornece uma boa documenta&ccedil;&atilde;o das APIs e &oacute;timas explica&ccedil;&otilde;es sobre o ciclo de vida dos aplicativos e sobre as t&eacute;cnicas adequadas de programa&ccedil;&atilde;o. Conv&eacute;m estudar o guia do desenvolvedor aqui: </span><span class="c6"><a href="http://developer.android.com/guide/index.html">http://developer.android.com/guide/index.html</a></span><span class="c1">.</span></p><p class="c0"><span class="c1">Obs: o emulador &eacute;, em geral, muito menos eficiente que um dispositivo m&oacute;vel real, principalmente em se tratando de opengl, portanto n&atilde;o eh bom para se testar o desempenho de um aplicativo.</span></p><p class="c0"><span class="c1">Como Android roda Linux, tamb&eacute;m &eacute; poss&iacute;vel escrever e compilar c&oacute;digo em C/C++ para android. Para isso, &eacute; fornecido o NDK, que &eacute; uma s&eacute;rie de ferramentas que, ao serem utilizadas em conjunto com o SDK para Android, permitem que o desenvolvedor escreva e compile partes do seu aplicativo em c&oacute;digo nativo, ou seja, utilizando linguagens nativas como C ou C++. A intera&ccedil;&atilde;o entre o c&oacute;digo Java e o c&oacute;digo nativo &eacute; feita com a utiliza&ccedil;&atilde;o da JNI (Java Native Interface), que &eacute; uma interface que permite que um c&oacute;digo que est&aacute; rodando em uma m&aacute;quina virtual chame e seja chamado por um c&oacute;digo nativo. Conv&eacute;m estudar a JNI neste bom livro: </span><span class="c6"><a href="http://www.google.com/url?q=http%3A%2F%2Fjava.sun.com%2Fdocs%2Fbooks%2Fjni%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGsJu3LEz0OqPprhgjabrD_jDBvDA">http://java.sun.com/docs/books/jni/</a></span><span class="c1"> e ler a documenta&ccedil;&atilde;o do NDK na pasta DOCS do NDK. </span></p><p class="c0"><span class="c1">Outro aspecto de extrema import&acirc;ncia &eacute; o conhecimento da problem&aacute;tica das diferentes vers&otilde;es do android. No EAD@Cel tentamos manter compatibilidade com o maior numero de vers&otilde;es poss&iacute;veis, visto que o processo de atualiza&ccedil;&atilde;o do android &eacute; bastante lento e burocr&aacute;tico, como mostra o gr&aacute;fico abaixo, de Janeiro de 2011, mostrando a percentagem de usu&aacute;rios atuais de cada vers&atilde;o do android.</span></p><p class="c0"><img height="250" src="images/image06.png" width="460"></p><p class="c0"></p><p class="c0"><a href="#" name="id.e7nen0-arwjzr"></a><span class="c1 c7">1.2 Comunica&ccedil;&atilde;o por v&iacute;deo:</span></p><p class="c0"><span class="c1">Conv&eacute;m pesquisar em livros e artigos para estudar os conceitos b&aacute;sicos da problem&aacute;tica da comunica&ccedil;&atilde;o por v&iacute;deo. Quest&otilde;es como v&iacute;deo-confer&ecirc;ncia, codifica&ccedil;&atilde;o/decodifica&ccedil;&atilde;o de v&iacute;deo, qualidade de v&iacute;deo, v&iacute;deo em dispositivos m&oacute;veis, etc.</span></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.adpwck-skgseb"></a><p class="c0"><span class="c1 c7">1.3 Programa&ccedil;&atilde;o de aplicativos de v&iacute;deo no android:</span></p><p class="c0"><span class="c1">Neste cap&iacute;tulo ser&atilde;o descritos os 3 m&eacute;todos mais comuns de se desenvolver aplicativos de v&iacute;deo para o Android, apenas para fins de conhecimento, visto que nenhum deles foi utilizado no EAD@Cel por motivos descritos neste cap&iacute;tulo.</span></p><p class="c0"><span class="c1 c19">1.3.1) M&eacute;todo 1</span><span class="c1">: as APIs padr&atilde;o para programa&ccedil;&atilde;o multim&iacute;dia no Android s&atilde;o as classes MediaPlayer e MediaRecorder.</span></p><p class="c0"><span class="c1 c19">1.3.1.1) Classe MediaPlayer:</span><span class="c1"> Para decodificar e exibir v&iacute;deo/&aacute;udio, a &uacute;nica API existente fornecida pelo Android &eacute; a classe MediaPlayer. (</span><span class="c6"><a href="http://developer.android.com/reference/android/media/MediaPlayer.html">http://developer.android.com/reference/android/media/MediaPlayer.html</a></span><span class="c1">). Seus pontos fortes s&atilde;o a utiliza&ccedil;&atilde;o do hardware para decodificar e a facilidade de uso. No entanto, ela n&atilde;o serve para aplica&ccedil;&otilde;es de comunica&ccedil;&atilde;o por v&iacute;deo em tempo real por v&aacute;rios motivos, entre eles:</span></p><ol class="c9"><li class="c8" value="1"><span class="c1">H&aacute; suporte apenas aos protocolos HTTP e RTSP. N&atilde;o &eacute; poss&iacute;vel utilizar outro protocolo (seja ele de um padr&atilde;o existente ou n&atilde;o). Como as bibliotecas do IVA implementam um pr&oacute;prio protocolo, esta limita&ccedil;&atilde;o da classe MediaPlayer se torna relevante ao EAD@Cel.</span></li><li class="c8"><span class="c1">Grande atraso na transmiss&atilde;o de v&iacute;deo ao vivo, o que tornaria frustrante uma aplica&ccedil;&atilde;o de intera&ccedil;&atilde;o em tempo real.</span></li><li class="c8"><span class="c1">Impossibilidade de acessar, via programa&ccedil;&atilde;o, os quadros e os dados dos quadros que v&atilde;o sendo decodificados. Isso nos impossibilitaria de utilizar bibliotecas do IVA para transmitir o v&iacute;deo, visto que n&atilde;o haveria como colocar os quadros nas filas do IVA.</span></li><li class="c8 c20"><span class="c1">Poucos codecs suportados, o que dificultaria a integra&ccedil;&atilde;o com outros sistemas que n&atilde;o utilizam estes codecs, como o IVA por exemplo.</span></li></ol><p class="c0"><span class="c1">Devido a essas limita&ccedil;&otilde;es, n&oacute;s descartamos a utiliza&ccedil;&atilde;o da classe MediaPlayer.</span></p><p class="c0"><span class="c1 c19">1.3.1.2) Classe MediaRecorder:</span><span class="c1"> Para codificar e enviar &aacute;udio/v&iacute;deo: mesmo problema, a &uacute;nica classe do android para codifica&ccedil;&atilde;o de v&iacute;deo em hardware (MediaRecorder) &eacute; pouco flex&iacute;vel, pois n&atilde;o permite o envio de um streaming em tempo real, visto que apenas salva o resultado da codifica&ccedil;&atilde;o em um arquivo local (ter&iacute;amos, portanto, que ir gerando esse arquivo e ir lendo ele ao mesmo tempo, o que seria pouco intuitivo e provavelmente pouco eficiente).</span></p><p class="c0"><span class="c1 c19">1.3.2) M&eacute;todo 2: </span><span class="c1">Na vers&atilde;o 2.2 do Android surgiu o suporte a flash, e a adobe possui uma API para v&iacute;deo-confer&ecirc;ncia em flash. No entanto, &eacute; de baixa flexibilidade pois todo o controle da v&iacute;deo-confer&ecirc;ncia (protocolo utilizado, codifica&ccedil;&atilde;o, exibi&ccedil;&atilde;o, etc) &eacute; controlado internamente pela API e &eacute; inacess&iacute;vel ao programador. Dessa forma, n&atilde;o &eacute; poss&iacute;vel integr&aacute;-la ao IVA. Al&eacute;m disso, a API da adobe n&atilde;o d&aacute; suporte a vers&otilde;es anteriores do android, e a qualidade da API ainda &eacute; duvidosa. Por esses motivos decidimos n&atilde;o utiliz&aacute;-la.</span></p><p class="c0"><span class="c1 c19">1.3.3) M&eacute;todo 3:</span><span class="c1"> Na vers&atilde;o 2.3 do Android, surgiram outras facilidades para o desenvolvimento de aplicativos de v&iacute;deo-confer&ecirc;ncia. No entanto, pelo mesmo motivo (n&atilde;o se sabe quanto tempo vai demorar para que a 2.3 se estabele&ccedil;a como dominante no mercado e queremos compatibilidade com vers&otilde;es anteriores) decidimos n&atilde;o utilizar essas facilidades.</span></p><p class="c0"><span class="c1">Logo, esta documenta&ccedil;&atilde;o assume a compatibilidade do aplicativo EAD@Cel considerando a utiliza&ccedil;&atilde;o de vers&otilde;es do android a partir da 1.5 em diante.</span></p><p class="c0"><span class="c1">A alternativa que utilizamos, melhor descrita no </span><span class="c6"><a href="#id.jt7185-r3755i">cap&iacute;tulo de implementa&ccedil;&atilde;o</a></span><span class="c1">, foi receber e decodificar o &aacute;udio/v&iacute;deo com as bibliotecas do IVA, que por sua vez utilizam as bibliotecas do FFMPEG. Os resultados foram &oacute;timos: apesar de ser em software, a decodifica&ccedil;&atilde;o se mostrou bastante eficiente e a recep&ccedil;&atilde;o com baixo delay. No entanto, a codifica&ccedil;&atilde;o &eacute; um pouco mais pesada que a decodifica&ccedil;&atilde;o. Mesmo assim obtivemos bons resultados. Logo, descartamos o uso dos 3 m&eacute;todos descritos neste cap&iacute;tulo e utilizamos as bibliotecas do IVA. </span></p><p class="c0"><span class="c22">&nbsp;</span></p><a href="#" name="id.jt7185-r3755i"></a><p class="c0"><span class="c22 c19">2 IMPLEMENTA&Ccedil;&Atilde;O</span></p><a href="#" name="id.ins8g5-vu9igv"></a><p class="c0"><span class="c1 c7">2.1 Quest&otilde;es de implementa&ccedil;&atilde;o:</span></p><p class="c0"><span class="c1">Caso as APIs padr&atilde;o do Android (MediaPlayer e MediaRecorder) n&atilde;o tivessem as limita&ccedil;&otilde;es que foram apresentadas no </span><span class="c6"><a href="#id.adpwck-skgseb">cap&iacute;tulo anterior</a></span><span class="c1">, com certeza seriam a melhor op&ccedil;&atilde;o, e a implementa&ccedil;&atilde;o ficaria desta forma:</span></p><ol class="c9"><li class="c8" value="1"><span class="c1">Captura: MediaRecorder</span></li><li class="c8"><span class="c1">Codifica&ccedil;&atilde;o: MediaRecorder (em hardware) + JNI para passar os frames ao C++</span></li><li class="c8"><span class="c1">Transmiss&atilde;o: biblioteca NET do IVA.</span></li><li class="c8"><span class="c1">Recebimento: biblioteca NET do IVA + JNI para passar os frames ao Java</span></li><li class="c8"><span class="c1">Decodifica&ccedil;&atilde;o: MediaPlayer (em hardware)</span></li><li class="c8 c20"><span class="c1">Renderiza&ccedil;&atilde;o: MediaPlayer</span></li></ol><p class="c0"><span class="c1">Para poder integrar o EAD@Cel ao IVA, o IVA precisaria garantir suporte aos codecs utilizados no EAD@Cel, que seriam os codecs suportados por default pelo hardware de aparelhos Android. Como o IVA usa FFMPEG, isso n&atilde;o seria dif&iacute;cil. Essa seria a implementa&ccedil;&atilde;o mais simples, intuitiva, eficiente e r&aacute;pida de ser desenvolvida. Infelizmente, como j&aacute; foi explicado, n&atilde;o &eacute; poss&iacute;vel. </span></p><p class="c0"><span class="c1">A solu&ccedil;&atilde;o que utilizamos foi a seguinte:</span></p><ol class="c9"><li class="c8" value="1"><span class="c1">Captura do v&iacute;deo e &aacute;udio: Classe &ldquo;Camera&rdquo; do Android (v&iacute;deo) + classe AudioRecord do Android (&aacute;udio) + JNI para passar os frames ao C++</span></li><li class="c8"><span class="c1">Codifica&ccedil;&atilde;o: biblioteca ENCODE do IVA (em software com ffmpeg).</span></li><li class="c8"><span class="c1">Transmiss&atilde;o: biblioteca NET do IVA.</span></li><li class="c8"><span class="c1">Recebimento: biblioteca NET do IVA.</span></li><li class="c8"><span class="c1">Decodifica&ccedil;&atilde;o: biblioteca DECODE do IVA (em software com ffmpeg).</span></li><li class="c8 c20"><span class="c1">Renderiza&ccedil;&atilde;o do v&iacute;deo e &aacute;udio: OpenGL (v&iacute;deo) + classe AudioTrack do Android (&aacute;udio) + JNI para usar o OpenGL em C++ e para passar os frames de audio ao Java.</span></li></ol><p class="c0"><span class="c1">Nessa solu&ccedil;&atilde;o escolhemos utilizar os codecs j&aacute; confirmadamente suportados pelo IVA, evitando ter de realizar alguma adapta&ccedil;&atilde;o ao IVA nesse sentido. Mais detalhes sobre essa solu&ccedil;&atilde;o, que &eacute; a que utilizamos, no </span><span class="c1 c31"><a href="#id.qp9rgs-nbrql6">cap&iacute;tulo seguinte</a></span><span class="c1">.</span></p><p class="c0"><span class="c1">&Eacute; importante citar que ainda haveria uma terceira alternativa de implementa&ccedil;&atilde;o. Como o Android &eacute; de c&oacute;digo aberto, essa alternativa seria copiar as libraries nativas (C/C++) internas (privadas) ao sistema operacional que interagem com as classes java MediaPlayer e MediaRecorder e com o hardware dos aparelhos e col&aacute;-las no nosso projeto EAD@Cel. Em seguida, compilar&iacute;amos essas libraries dentro do nosso projeto. Desse modo, ter&iacute;amos acesso aos quadros codificados/decodificados pelo hardware e, desse modo, poder&iacute;amos utilizar a lib NET do IVA para realizar a transmiss&atilde;o/recep&ccedil;&atilde;o desses quadros. Assim, a implementa&ccedil;&atilde;o ficaria desta forma:</span></p><ol class="c9"><li class="c8" value="1"><span class="c1">Captura: c&acirc;mera e microfone seriam acessados diretamente pelo C++, utilizando as libraries privadas do android correspondentes.</span></li><li class="c8"><span class="c1">Codifica&ccedil;&atilde;o: em hardware, utilizando as libraries privadas do android correspondentes.</span></li><li class="c8"><span class="c1">Transmiss&atilde;o: lib NET do IVA.</span></li><li class="c8"><span class="c1">Recep&ccedil;&atilde;o: lib NET do IVA.</span></li><li class="c8"><span class="c1">Decodifica&ccedil;&atilde;o: em hardware, utilizando as libraries privadas do android correspondentes.</span></li><li class="c8 c20"><span class="c1">Renderiza&ccedil;&atilde;o: display e alto falante seriam acessados diretamente pelo C++, utilizando as libraries privadas do android correspondentes.</span></li></ol><p class="c0"><span class="c1">Contudo, como as bibliotecas nativas interagem com o resto do Android, e o sistema operacional muda muito a cada nova vers&atilde;o (e muda a cada modelo de aparelho tamb&eacute;m, mesmo dentro de uma mesma vers&atilde;o), haveria grande probabilidade do aplicativo deixar de funcionar em diferentes vers&otilde;es do Android ou funcionar apenas no modelo de aparelho cujo c&oacute;digo utilizamos, e a manuten&ccedil;&atilde;o para faz&ecirc;-lo voltar a funcionar ou para que funcione em m&uacute;ltiplos aparelhos com certeza seria invi&aacute;vel em termos de complexidade. Por esses motivos, tal uso das bibliotecas privadas do android n&atilde;o deve ser feito, segundo os desenvolvedores do Android. Al&eacute;m disso, com essa solu&ccedil;&atilde;o estar&iacute;amos limitados a utilizar os codecs suportados por default pelos aparelhos android. Por todos esses motivos, descartamos essa alternativa.</span></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.qp9rgs-nbrql6"></a><p class="c0"><span class="c1 c7">2.2 Documenta&ccedil;&atilde;o da implementa&ccedil;&atilde;o do EAD@Cel:</span></p><p class="c0"><span class="c1">Pode-se dividir nas seguintes partes:</span></p><p class="c0"><span class="c1">Captura, codifica&ccedil;&atilde;o, transmiss&atilde;o, recep&ccedil;&atilde;o, decodifica&ccedil;&atilde;o e renderiza&ccedil;&atilde;o de v&iacute;deo/&aacute;udio:</span></p><p class="c0"><span class="c1 c19">2.2.1) Captura:</span></p><p class="c0"><span class="c1 c19">2.2.1.1) Captura de v&iacute;deo:</span><span class="c1"> desenvolvemos uma classe em Java chamada Preview (que est&aacute; no arquivo src/Camera.java). A classe utiliza uma API do Android chamada &ldquo;Camera&rdquo;. Com o auxilio dessa API, nossa classe &ldquo;Preview&rdquo; seta os par&acirc;metros de captura desejados (resolu&ccedil;&atilde;o, quadros/s, etc) e envia cada frame capturado no formato YUV420SP (tamb&eacute;m conhecido como NV21, que &eacute; o &uacute;nico formato de captura suportado por todos os aparelhos android) para o C++, que ir&aacute; fazer a codifica&ccedil;&atilde;o dos frames com as libs do IVA + ffmpeg.</span></p><p class="c0"><span class="c1">Um detalhe que conv&eacute;m citar &eacute; a utiliza&ccedil;&atilde;o de &ldquo;Java reflection&rdquo; para que se possa utilizar a fun&ccedil;&atilde;o setPreviewCallbackWithBuffer em vers&otilde;es do android anteriores a 2.2, quase dobrando a taxa de frames, visto que essa fun&ccedil;&atilde;o evita que o GC (garbage collector do android) interrompa o programa a cada frame.</span></p><p class="c0"><span class="c1 c19">2.2.1.2) Captura de &aacute;udio: </span><span class="c1">desenvolvemos uma classe em Java chamada Mic (que est&aacute; no arquivo Mic.java). Ela utiliza a API do Android chamada AudioRecord, e faz a captura do audio do microfone. Cada frame capturado &eacute; enviado ao C++ no formato RAW (PCM), aonde ser&aacute; feita a codifica&ccedil;&atilde;o com as libs do iva+ffmpeg.</span></p><p class="c0"><span class="c1 c19">2.2.2) Codifica&ccedil;&atilde;o:</span><span class="c1"> A codifica&ccedil;&atilde;o do &aacute;udio e do v&iacute;deo &eacute; feita em software com as libs do iva que utilizam o ffmpeg.</span></p><p class="c0"><span class="c1 c19">2.2.3) Transmiss&atilde;o:</span><span class="c1"> a transmiss&atilde;o &eacute; feita com as libs do iva.</span></p><p class="c0"><span class="c1 c19">2.2.4) Recep&ccedil;&atilde;o:</span><span class="c1"> feita com as libs do iva.</span></p><p class="c0"><span class="c1 c19">2.2.5) Decodifica&ccedil;&atilde;o: </span><span class="c1">em software, feita com as libs do iva que utilizam o ffmpeg;</span></p><p class="c0"><span class="c1 c19">2.2.6) Renderiza&ccedil;&atilde;o:</span><span class="c1"> esta talvez foi a parte mais trabalhosa do aplicativo visto que, em vers&otilde;es anteriores a 2.3 do android, n&atilde;o h&aacute; como renderizar &aacute;udio nem v&iacute;deo diretamente do C/C++. Ou seja, &eacute; preciso utilizar alguma API Java para realizar a renderiza&ccedil;&atilde;o, mas os nossos frames decodifcados est&atilde;o no C++. Dessa forma, o m&eacute;todo mais eficiente que encontramos para renderizar os frames de &aacute;udio e de v&iacute;deo foi o seguinte:</span></p><p class="c0"><span class="c1 c19">2.2.6.1) Renderiza&ccedil;&atilde;o do v&iacute;deo:</span><span class="c1"> utilizamos OpenGL em C++, desenhando um ret&acirc;ngulo com as dimens&otilde;es desejadas e aplicando o frame de v&iacute;deo decodificado como textura RGB ao ret&acirc;ngulo. (conv&eacute;m estudar openGL em C++ para android, e verificar o sample fornecido na NDK no diret&oacute;rio samples/san-angeles). </span></p><p class="c0"><span class="c1">&Eacute; importante citar que criamos um arquivo src/GLSurfaceView_FFMPEG.java que extende a classe SurfaceView do Android e possibilita que chamemos a fun&ccedil;&atilde;o SwapBuffers do OpenGL do Java a partir do C++, &nbsp;evitando, assim, ter de retornar ao onDrawFrame do Java com um &ldquo;return&rdquo; no C++, o que torna o c&oacute;digo muito mais simples, leg&iacute;vel e de mais f&aacute;cil manuten&ccedil;&atilde;o.</span></p><p class="c0"><span class="c1">Outro detalhe importante, caso o frame decodificado esteja numa resolu&ccedil;&atilde;o, e se queira renderiz&aacute;-lo em outra, verificamos que realizando esse redimensionamento com o ffmpeg &eacute; mais lento que com o opengl. Ainda assim, caso a vers&atilde;o do OpenGL do aparelho utilizado seja a 1.0, o redimensionamento &eacute; muito lento pois &eacute; feito em software. Caso seja 1.1 em diante, pode-se realiz&aacute;-lo sem problemas pois &eacute; em hardware e &eacute; bem eficiente.</span></p><p class="c0"><span class="c1">Outro detalhe: algumas vers&otilde;es do OpenGL suportam apenas texturas sobre ret&acirc;ngulos de resolu&ccedil;&atilde;o cujas dimens&otilde;es s&atilde;o pot&ecirc;ncia de 2. &Eacute; pra isso que serve nossa fun&ccedil;&atilde;o &ldquo;apply_first_texture&rdquo;, que gera um ret&acirc;ngulo com dimens&otilde;es de pot&ecirc;ncia de dois imediatamente maiores que as que ir&atilde;o ser utilizadas. Em seguida, a cada frame, aplica-se a textura com qualquer dimens&atilde;o sobre parte desse ret&acirc;ngulo.</span></p><p class="c0"><span class="c1">Tamb&eacute;m realizamos c&aacute;lculos considerando a resolu&ccedil;&atilde;o m&aacute;xima da tela e a orienta&ccedil;&atilde;o do celular para que a exibi&ccedil;&atilde;o do v&iacute;deo esteja sempre centralizada na tela, independentemente da resolu&ccedil;&atilde;o e da orienta&ccedil;&atilde;o.</span></p><p class="c0"><span class="c1 c19">2.2.6.2) Renderiza&ccedil;&atilde;o do &aacute;udio:</span><span class="c1"> criamos o arquivo src/AudioThread.java que utiliza a API do Android chamada AudioTrack. Essa API toca frames de audio que s&atilde;o entregues a ela no formato RAW (PCM). Para isso ajustamos corretamente os par&acirc;metros da AudioTrack. Para enviarmos os frames de &aacute;udio do C++ para o Java, primeiramente tentamos chamar uma fun&ccedil;&atilde;o Java a partir do C++ utilizando a JNI, passando como par&acirc;metro o frame, que seria a solu&ccedil;&atilde;o mais simples. No entanto, esta solu&ccedil;&atilde;o ativa o Garbage collector a cada frame, o que causa uma enorme queda no desempenho, logo essa alternativa foi descartada. A alternativa que implementamos para evitar o GC foi utilizar uma t&eacute;cnica da JNI um pouco mais trabalhosa. Em resumo, essa t&eacute;cnica consiste na cria&ccedil;&atilde;o de um array em Java que representa um frame e de um array em C++ que tamb&eacute;m representa um frame. Em seguida, com chamadas a algumas fun&ccedil;&otilde;es da JNI, associamos os dois arrays para a mesma posi&ccedil;&atilde;o da memoria para que eles sejam tratados como se fossem um s&oacute;. Assim, cada vez que se atualiza o array do C++ com os dados do novo frame decodificado, essa atualiza&ccedil;&atilde;o &eacute; automaticamente propagada ao array do java, sem que seja feita nenhuma c&oacute;pia e nenhuma aloca&ccedil;&atilde;o de memoria adicional, resultando na solu&ccedil;&atilde;o mais eficiente que encontramos para renderizar o &aacute;udio.</span></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.jecxv8lmv592"></a><p class="c0"><span class="c1 c7">2.3 Diagramas de sequ&ecirc;ncia</span></p><p class="c0"><span class="c1">Para melhor visualizar as rela&ccedil;&otilde;es entre as classes e as chamadas nativas, apresentamos 2 diagramas de sequ&ecirc;ncia numa nota&ccedil;&atilde;o semi-formal.</span></p><p class="c0"><span class="c1 c19">2.3.1) Diagrama do processo de recebimento de v&iacute;deo e &aacute;udio:</span></p><p class="c0"><span class="c1">O diagrama abaixo ajuda a compreender o processo de recebimento de v&iacute;deo e &aacute;udio, mostrando as principais classes envolvidas e as fun&ccedil;&otilde;es contidas no arquivo eadcel.cpp. O ret&acirc;ngulo vermelho representa o estado, definido no c&oacute;digo atrav&eacute;s de 3 la&ccedil;os em s&eacute;rie, onde o aplicativo permanece recebendo &aacute;udio e/ou v&iacute;deo. </span></p><p class="c0"><img height="503" src="images/image00.png" width="623"></p><p class="c0"><span class="c1 c19">2.3.2) Diagrama do processo de envio de v&iacute;deo:</span></p><p class="c0"><span class="c1">Abaixo o ret&acirc;ngulo vermelho mostra o estado em que os frames capturados pela classe Preview s&atilde;o continuamente transferidos para a parte nativa, onde ocorre a codifica&ccedil;&atilde;o e o envio pelas threads do codificador e do emissor, chamados respectivamente no c&oacute;digo como video_enc e como netSendVideo.</span></p><p class="c0"><img height="455" src="images/image10.png" width="628"></p><p class="c0"><span class="c1 c19">2.3.3) Diagrama do processo de envio de &aacute;udio:</span></p><p class="c0"><span class="c1">Semelhante ao que ocorre no envio do v&iacute;deo, o diagrama a seguir mostra a classe Mic, que &eacute; uma thread que permanece no estado running utilizando o objeto AudioRecord (omitido abaixo) para capturar os bytes do frame em PCM. Logo a seguir o frame &eacute; enviado atrav&eacute;s da fun&ccedil;&atilde;o nativeSenderAudio para que as threads nativas definidas no eadcel.cpp fa&ccedil;am a codifica&ccedil;&atilde;o e o envio. </span></p><p class="c0"><img height="456" src="images/image07.png" width="610"></p><p class="c0"><span class="c1">Os diagramas de envio foram mostrados separadamente para facilitar a legibilidade de cada processo. Na op&ccedil;&atilde;o de enviar v&iacute;deo juntamente com &aacute;udio, os processos s&atilde;o disparados um ap&oacute;s o outro. Primeiro o envio de &aacute;udio e depois o envio de v&iacute;deo.</span></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="kix.q0ykdf-dapsey"></a><p class="c0"><span class="c1 c7">2.4 Estrutura de diret&oacute;rios e arquivos importantes:</span></p><p class="c0"><span class="c1">Graficamente o projeto se estrutura da seguinte forma:</span></p><p class="c0"><img height="432" src="images/image08.png" width="196"></p><ol class="c9"><li class="c8" value="1"><span class="c1">A pasta &ldquo;src&rdquo; cont&eacute;m os arquivos Java do projeto. </span></li><li class="c8"><span class="c1">A pasta &ldquo;jni&rdquo; cont&eacute;m os arquivos C/C++ do projeto.</span></li><li class="c8"><span class="c1">A pasta &ldquo;libs&rdquo; recebe automaticamente os bin&aacute;rios &ldquo;.so&rdquo; resultantes da compila&ccedil;&atilde;o dos arquivos C/C++.</span></li><li class="c8"><span class="c1">A pasta &ldquo;libsFFMPEG&rdquo; deve sempre conter os bin&aacute;rios &ldquo;.so&rdquo; resultantes da compila&ccedil;&atilde;o do ffmpeg. Em outras palavras, cada vez que se recompilar o ffmpeg, o resultado da compila&ccedil;&atilde;o deve ser manualmente retirado da pasta &ldquo;libs&rdquo; e colocado na pasta &ldquo;libsFFMPEG&rdquo;, pois ainda n&atilde;o fizemos um script que fa&ccedil;a isso automaticamente.</span></li><li class="c8"><span class="c1">A pasta &ldquo;libsIVA&rdquo; recebe automaticamente os bin&aacute;rios &ldquo;.so&rdquo; resultantes da compila&ccedil;&atilde;o dos arquivos do IVA.</span></li><li class="c8"><span class="c1">A pasta &ldquo;res&rdquo; cont&eacute;m os arquivos de layout da interface.</span></li><li class="c8 c20"><span class="c1">O arquivo &ldquo;scriptAndroid.sh&rdquo; &eacute; um script que fizemos para automatizar o seguinte: ao compilar as libs do IVA, o script coloca o resultado da compila&ccedil;&atilde;o na pasta &ldquo;libsIVA&rdquo;. E ao compilar o m&oacute;dulo &ldquo;eadcel&rdquo;, o script copia os &ldquo;.so&rdquo; relevantes das pastas &ldquo;libsFFMPEG&rdquo; e &ldquo;libsIVA&rdquo; para a pasta &ldquo;libs&rdquo;. Isso evita termos de copi&aacute;-los manualmente ou termos de recompilar o IVA e o FFMPEG toda vez que se quer compilar apenas o m&oacute;dulo eadcel, visto que a NDK apaga os arquivos da pasta &ldquo;libs&rdquo; antes de compilar qualquer coisa.</span></li></ol><p class="c0"><span class="c1">Graficamente, a pasta src:</span></p><p class="c0"><img height="274" src="images/image04.png" width="277"></p><ol class="c9"><li class="c8" value="1"><span class="c1">AudioThread.java: recebe os frames de &aacute;udio do C++ e renderiza o &aacute;udio.</span></li><li class="c8"><span class="c1">Camera.java: captura os frames da c&acirc;mera e os envia ao C++.</span></li><li class="c8"><span class="c1">DemoRenderer.java: opengl em Java para renderizar os frames.</span></li><li class="c8"><span class="c1">eadcel.java: ponto inicial de execu&ccedil;&atilde;o do programa.</span></li><li class="c8"><span class="c1">GLSurfaceView_FFMPEG.java: permite usar a fun&ccedil;&atilde;o SwapBuffers.</span></li><li class="c8 c20"><span class="c1">Mic.java: captura os frames do microfone e os envia ao C++.</span></li></ol><p class="c0"><span class="c1">Graficamente, a pasta &ldquo;jni&rdquo;:</span></p><p class="c0"><img height="775" src="images/image03.png" width="245"></p><ol class="c9"><li class="c8" value="1"><span class="c1">A pasta &ldquo;jni/eadcelnative&rdquo; cont&eacute;m os arquivos C++ do m&oacute;dulo eadcel.</span></li><li class="c8"><span class="c1">A pasta &ldquo;jni/iva&rdquo; cont&eacute;m os arquivos C++ dos m&oacute;dulos do IVA.</span></li><li class="c8"><span class="c1">As outras pastas &ldquo;jni/*&rdquo; cont&eacute;m os arquivos C dos m&oacute;dulos do ffmpeg.</span></li><li class="c8"><span class="c1">O arquivo &ldquo;jni/Android.mk&rdquo; &eacute; o makefile que a NDK necessita para compilar o c&oacute;digo C/C++. A estrutura desse arquivo &eacute; dividida em m&oacute;dulos (eadcel, encode, net, queue, &hellip; , avcodec, avutil, etc). Para escolher quais desses m&oacute;dulos se quer compilar, deve-se usar o arquivo &ldquo;jni/Application.mk&rdquo;</span></li><li class="c8"><span class="c1">O arquivo &ldquo;jni/AndroidFFMPEG.mk&rdquo; &eacute; o makefile do ffmpeg compil&aacute;vel no android, sem as nossas altera&ccedil;&otilde;es. Esse arquivo n&atilde;o &eacute; utilizado, serve apenas para consulta.</span></li><li class="c8"><span class="c1">O arquivo &ldquo;jni/Application.mk&rdquo; serve para escolher quais m&oacute;dulos se deseja compilar.</span></li><li class="c8"><span class="c1">O arquivo &ldquo;config.h&rdquo; informa ao ffmpeg quais codecs e op&ccedil;&otilde;es devem ser ativadas no ffmpeg. Esse arquivo &eacute; alterado automaticamente quando se roda o script &ldquo;jni/configure-android.sh&rdquo;. Obs: ap&oacute;s alterado automaticamente, deve-se alter&aacute;-lo manualmente da seguinte forma: </span></li></ol><p class="c35"><span class="c1">trocar</span></p><p class="c35"><span class="c15">#define restrict restrict</span></p><p class="c35"><span class="c1">por </span></p><p class="c35"><span class="c15">#define restrict __restrict</span></p><p class="c35"><span class="c1">e trocar</span></p><p class="c35"><span class="c15">#define HAVE_LOG2 1</span></p><p class="c35"><span class="c15">#define HAVE_LOG2F 1</span></p><p class="c35"><span class="c1">por</span></p><p class="c35"><span class="c15">#define HAVE_LOG2 0</span></p><p class="c35"><span class="c15">#define HAVE_LOG2F 0</span></p><ol class="c9"><li class="c8" value="1"><span class="c1">O arquivo &ldquo;jni/configure-android.sh&rdquo; &eacute; um script que deve ser editado e rodado quando se quer alterar alguma configura&ccedil;&atilde;o do ffmpeg. Os m&oacute;dulos do ffmpeg afetados pela altera&ccedil;&atilde;o devem ser recompilados.</span></li><li class="c8"><span class="c1">O arquivo &ldquo;eadcel.cpp&rdquo; pertence ao m&oacute;dulo eadcel.</span></li><li class="c8 c20"><span class="c1">Os outros arquivos n&atilde;o citados da pasta &ldquo;jni&rdquo; pertencem ao ffmpeg.</span></li></ol><p class="c0"><span class="c1">&nbsp;</span></p><p class="c0"><a href="#" name="id.jlosd-n06163"></a><span class="c1 c7">2.5 Diagramas de classes java:</span></p><p class="c0"><span class="c1 c19">2.5.1)</span><span class="c1"> Classes mais importantes referentes aos arquivos eadcel.java, Camera.java, DemoGLSurfaceView.java, DemoRenderer.java e &nbsp;GLSurfaceView_FFMPEG.java:</span></p><p class="c0"><img height="827" src="images/image02.png" width="614"></p><p class="c0"><span class="c1 c19">2.5.2)</span><span class="c1"> Classe do arquivo AudioThread.java:</span></p><p class="c0"><img height="225" src="images/image05.png" width="445"></p><p class="c0"><span class="c1 c19">2.5.3)</span><span class="c1"> Classes do arquivo Mic.java:</span></p><p class="c0"><img height="205" src="images/image01.png" width="525"></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.9zbuof-nl5y9j"></a><p class="c0"><span class="c22 c19">3 CONFIGURA&Ccedil;&Atilde;O DO AMBIENTE QUE UTILIZAMOS</span></p><a href="#" name="id.xiaalc-e7eqf"></a><p class="c0"><span class="c1 c7">3.1 Configura&ccedil;&atilde;o de rede:</span></p><p class="c0"><span class="c1">Foi usado um roteador wireless D-Link DIR-615 com ip 143.54.132.96. Cada celular ligado ao roteador recebeu um ip est&aacute;tico interno diferente. Por exemplo, um celular 192.168.0.120 e o outro 192.168.0.123. Para receber a transmiss&atilde;o no celular 120 setamos o port-forwarding conforme a figura:</span></p><p class="c0"><img height="496" src="images/image09.png" width="621"></p><p class="c0"><span class="c1">Obs: pode-se utilizar outro roteador ou outra configura&ccedil;&atilde;o de rede.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.tjeqqv-dz9w8j"></a><p class="c0"><span class="c1 c7">3.2 Instala&ccedil;&atilde;o e configura&ccedil;&atilde;o das ferramentas:</span></p><p class="c0"><span class="c1">Instalar ferramentas necess&aacute;rias para o desenvolvimento no Android seguindo o guia de instala&ccedil;&atilde;o em </span><span class="c6"><a href="http://developer.android.com/sdk/installing.html">http://developer.android.com/sdk/installing.html</a></span></p><p class="c0"><span class="c1">Recomenda-se usar linux pois a NDK &eacute; muito mais simples de ser utilizada no linux. No Windows teria que se utilizar cygwin.</span></p><p class="c0"><span class="c1 c19">3.2.1) Instalar Eclipse:</span><span class="c1"> recomendado pois o ADT plugin s&oacute; funciona no eclipse.</span></p><p class="c0"><span class="c1 c19">3.2.2) Instalar a SDK: </span><span class="c1">&eacute; o kit de desenvolvimento para android. Fornece as APIs para o desenvolvimento de aplicativos para Android em Java.</span></p><p class="c0"><span class="c1 c19">3.2.3) Instalar o ADT plugin:</span><span class="c1"> estende as capacidades do eclipse com ferramentas espec&iacute;ficas para o desenvolvimento de aplicativos no android (por exemplo, setup facilitado de novos projetos, debug, desenvolvimento gr&aacute;fico de interfaces, etc).</span></p><p class="c0"><span class="c1 c19">3.2.4) Instalar a JDK 5 ou 6</span><span class="c1">; </span></p><p class="c0"><span class="c1 c19">3.2.5) Instalar todas as plataformas e componentes da SDK</span><span class="c1">;</span></p><p class="c0"><span class="c1 c19">3.2.6) Instalar a NDK</span><span class="c1">: N&atilde;o estamos utilizando a NDK oficial do android, pois o suporte dela &agrave; STL (Standard Template Library) e a excess&otilde;es &eacute; ruim. A ndk que estamos usando &eacute; 100% compat&iacute;vel. Este &eacute; o link: </span><span class="c6"><a href="http://www.google.com/url?q=http%3A%2F%2Fsmartctl.net%2Fdata%2Fandroid-ndk-r4-windows-crystax-1.zip&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNFdW7T6AJca5NQ6h65cN58KuY8EZw">http://smartctl.net/data/android-ndk-r4-windows-crystax-1.zip</a></span></p><p class="c0"><span class="c1">Importante: Caso seja necess&aacute;rio recompilar algum m&oacute;dulo do ffmpeg, utilizar exatamente esta vers&atilde;o do link acima, pois vers&otilde;es mais novas da NDK, incluindo a vers&atilde;o oficial, resultam numa queda de desempenho na codifica&ccedil;&atilde;o dos frames (ainda n&atilde;o sabemos o motivo).</span></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.i3x89c-3rr6l"></a><p class="c0"><span class="c1 c7">3.3 Processo de compila&ccedil;&atilde;o:</span></p><p class="c0"><span class="c1">Foram utilizadas as seguintes bibliotecas (libs) do IVA: thread, common, sockets, queue, net , decode e encode. Essas libs foram compiladas primeiramente para Linux (Ubuntu), atrav&eacute;s do CMake, e depois pelo compilador da NDK (ndk-build). Utilizamos os seguintes arquivos na compila&ccedil;&atilde;o do projeto:</span></p><p class="c0"><span class="c1 c19">3.3.1) Android.mk: </span><span class="c1">define os arquivos fonte e as localiza&ccedil;&otilde;es dos headers de cada m&oacute;dulo a ser compilado pela NDK. Os m&oacute;dulos s&atilde;o os seguintes: eadcel, thread, common, sockets, net, decode, encode, avutil, avcodec.</span></p><p class="c0"><span class="c1 c19">3.3.2) Application.mk:</span><span class="c1"> arquivo auxiliar para a escolha dos m&oacute;dulos a serem compilados no momento. Essa escolha ocorre simplesmente comentando-se as linhas onde est&atilde;o os m&oacute;dulos que n&atilde;o precisam ser compilados. O exemplo a seguir faz a compila&ccedil;&atilde;o apenas do m&oacute;dulo eadcel:</span></p><p class="c3"><span class="c15">#APP_MODULES := thread common sockets queue net decode encode</span></p><p class="c3"><span class="c15">APP_MODULES := eadcel</span></p><p class="c0"><span class="c15">#APP_MODULES := avutil avcodec</span></p><p class="c0"><span class="c1 c19">3.3.3) scriptAndroid.sh:</span><span class="c1"> script localizado na raiz do diret&oacute;rio do projeto, utilizado para executar o ndk-build fazendo a compila&ccedil;&atilde;o dos m&oacute;dulos referentes &agrave;s libs do IVA (libsIVA) e o m&oacute;dulo contendo a parte nativa (C/C++) do programa eadcel e automatizando algumas tarefas p&oacute;s-compila&ccedil;&atilde;o. As libs do FFMPEG n&atilde;o devem ser compiladas com esse script. Para compilar as libs do FFMPEG, simplesmente deve-se escolher os m&oacute;dulos do ffmpeg desejados com o arquivo &ldquo;Application.mk&rdquo;, executar </span><span class="c36">../../android-ndk-r4-crystax/ndk-build na linha de comando e copiar os bin&aacute;rios &ldquo;.so&rdquo; da pasta libs para a pasta libsFFMPEG.</span></p><p class="c0"><span class="c1">A seguir uma breve explica&ccedil;&atilde;o das partes importantes do scriptAndroid.sh:</span></p><p class="c0"><span class="c1 c19">3.3.3.1) Comando relativo ao ndk-build. </span><span class="c1">Neste caso foi utilizada a ndk-r4-crystax (vers&atilde;o 1):</span></p><p class="c0"><span class="c15">NDKBUILD=&quot;../../android-ndk-r4-crystax/ndk-build&quot;</span></p><p class="c0"><span class="c1 c19">3.3.3.2) Vari&aacute;veis relativas &agrave;s bibliotecas do FFMPEG:</span></p><p class="c3"><span class="c15">LIBAVCODEC=&quot;libsFFMPEG/libavcodec.so&quot;</span></p><p class="c3"><span class="c15">LIBAVFORMAT=&quot;libsFFMPEG/libavformat.so&quot;</span></p><p class="c3"><span class="c15">LIBAVUTIL=&quot;libsFFMPEG/libavutil.so&quot;</span></p><p class="c0"><span class="c15">LIBSWSCALE=&quot;libsFFMPEG/libswscale.so&quot;</span></p><p class="c0"><span class="c1 c19">3.3.3.3) Diret&oacute;rio onde ficam localizadas todas as bibliotecas nativas compiladas:</span></p><p class="c0"><span class="c15">ARMEABI=&quot;libs/armeabi&quot;</span></p><p class="c0"><span class="c1 c19">3.3.3.4) </span><span class="c1">Diret&oacute;rio onde as bibliotecas do IVA ficam dispon&iacute;veis caso a compila&ccedil;&atilde;o no momento n&atilde;o tenha o objetivo de compilar as libs do IVA, evitando assim que sejam perdidos os bin&aacute;rios &ldquo;.so&rdquo; da pasta definida em ARMEABI. Isso ocorre conforme a escolha dos m&oacute;dulos no arquivo application.mk, descrito anteriormente:</span></p><p class="c0"><span class="c15">LIBSIVA=&quot;libsIVA&quot;</span></p><p class="c0"><span class="c1">A seguir as localiza&ccedil;&otilde;es das libs do IVA a serem copiadas pelo scriptAndroid.sh para a pasta ARMEABI:</span></p><p class="c3"><span class="c15">LIBCOMMON=&quot;libsIVA/libcommon.so&quot;</span></p><p class="c3"><span class="c15">LIBTHREAD=&quot;libsIVA/libthread.so&quot;</span></p><p class="c3"><span class="c15">LIBSOCKETS=&quot;libsIVA/libsockets.so&quot;</span></p><p class="c3"><span class="c15">LIBQUEUE=&quot;libsIVA/libqueue.so&quot;</span></p><p class="c3"><span class="c15">LIBNET=&quot;libsIVA/libnet.so&quot;</span></p><p class="c3"><span class="c15">LIBDECODE=&quot;libsIVA/libdecode.so&quot;</span></p><p class="c0"><span class="c15">LIBENCODE=&quot;libsIVA/libencode.so&quot;</span></p><p class="c0"><span class="c1 c19">3.3.3.5) </span><span class="c1">Ao final do scriptAndroid.sh s&atilde;o feitas verifica&ccedil;&otilde;es sobre qual tipo de compila&ccedil;&atilde;o foi escolhida. Por exemplo: se achar a libcommon.so no diret&oacute;rio ARMEABI, significa que o application.mk esta definido para compilar as bibliotecas do IVA, gerando um arquivo bin&aacute;rio .so novo para cada uma delas. Esses novos arquivos de extens&atilde;o &ldquo;so&rdquo; s&atilde;o ent&atilde;o copiados para a pasta LIBSIVA para que nao seja necess&aacute;rio compila-los quando se quiser gerar apenas o arquivo eadcel.so. Caso contr&aacute;rio, se a libcommon.so nao for encontrada no diret&oacute;rio ARMEABI, significa que o application.mk est&aacute; definido para compilar apenas o eadcel.so. Ent&atilde;o, os .so das bibliotecas do iva que est&atilde;o no diret&oacute;rio LIBSIVA ser&atilde;o copiados para a pasta ARMEABI, evitando assim a sua recompila&ccedil;&atilde;o.</span></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.s9nq3v-pivp8c"></a><p class="c0"><span class="c22 c19">4 TESTES DE DESEMPENHO</span></p><p class="c0"><span class="c1">Para medir a taxa de frames de v&iacute;deo e de &aacute;udio, foi implementada uma fun&ccedil;&atilde;o de benchmark, especificada nos arquivos bench.cpp e bench.h que fazem parte do m&oacute;dulo eadcel. Para realizar uma medi&ccedil;&atilde;o &eacute; necess&aacute;rio usar as seguintes fun&ccedil;&otilde;es, exemplificadas abaixo:</span></p><p class="c0"><span class="c1">a) initBenchVar(&amp;videocapt, 30000, &quot;CAPTURA DE VIDEO&quot;): usada para criar uma medi&ccedil;&atilde;o. No caso &eacute; usada a vari&aacute;vel videocapt, com 30000 ms de intervalo para a coleta das informa&ccedil;&otilde;es. O &uacute;ltimo par&acirc;metro d&aacute; o nome da medi&ccedil;&atilde;o.</span></p><p class="c0"><span class="c1">b) beginPoint(&amp;videocapt): inicializa a medi&ccedil;&atilde;o no in&iacute;cio do trecho do c&oacute;digo a ser medido.</span></p><p class="c0"><span class="c1">c) endPoint(&amp;videocapt): finaliza a medi&ccedil;&atilde;o ao final do trecho de c&oacute;digo medido. </span></p><p class="c0"><span class="c1">A tabela a seguir mostra algumas informa&ccedil;&otilde;es sobre os aparelhos que foram utilizados nos testes:</span></p><table cellpadding="0" cellspacing="0" class="c27"><tbody><tr><td class="c2"><p class="c3"><span class="c1">&nbsp;</span></p></td><td class="c2"><p class="c3"><span class="c1">Processador</span></p></td><td class="c2"><p class="c3"><span class="c1">Vers&atilde;o de firmware</span></p></td><td class="c2"><p class="c3"><span class="c1">Resolu&ccedil;&atilde;o m&aacute;xima da tela</span></p></td><td class="c2"><p class="c29"><span class="c1">Vers&atilde;o do OpenGL</span></p></td></tr><tr><td class="c2"><p class="c3"><span class="c1">Motorola Milestone A853</span></p></td><td class="c2"><p class="c3"><span class="c1">500MHz</span></p></td><td class="c2"><p class="c3"><span class="c1">2.0.1</span></p></td><td class="c2"><p class="c3"><span class="c1">480 X 854</span></p></td><td class="c2"><p class="c29"><span class="c1">1.0</span></p></td></tr><tr><td class="c2"><p class="c3"><span class="c1">Samsung Galaxy GT-I9000B</span></p></td><td class="c2"><p class="c3"><span class="c1">1 GHz</span></p></td><td class="c2"><p class="c3"><span class="c1">2.1-update1</span></p></td><td class="c2"><p class="c3"><span class="c1">480 X 800</span></p></td><td class="c2"><p class="c29"><span class="c1">1.1</span></p></td></tr></tbody></table><p class="c0"><span class="c1">Tabela 1 - Aparelhos Utilizados</span></p><p class="c0"><span class="c1">&nbsp;</span></p><a href="#" name="id.v7lzl3-mxwcz5"></a><p class="c0"><span class="c1 c7">4.1 Teste 1: Transmitindo com o Samsung e recebendo com o Milestone</span></p><p class="c0"><span class="c1">A tabela abaixo mostra os testes realizados onde foi utilizado um Motorola Milestone enviando v&iacute;deo e &aacute;udio em tempo real para um Samsung Galaxy.</span></p><p class="c0"><span class="c1">Os par&acirc;metros de codifica&ccedil;&atilde;o de v&iacute;deo utilizados foram:</span></p><ol class="c9"><li class="c8" value="1"><span class="c1">Resolu&ccedil;&atilde;o: 320x240;</span></li><li class="c8"><span class="c1">Codec: MPEG4;</span></li><li class="c8"><span class="c1">Taxa de bits: 256Kbps;</span></li><li class="c8"><span class="c1">GOP: 12;</span></li><li class="c8 c20"><span class="c1">Taxa de frames: 15/s.</span></li></ol><p class="c0"><span class="c1">Os par&acirc;metros de codifica&ccedil;&atilde;o de &aacute;udio utilizados foram:</span></p><ol class="c9"><li class="c8" value="1"><span class="c1">Codec: MP2;</span></li><li class="c8"><span class="c1">Taxa de bits: 64Kbps;</span></li><li class="c8"><span class="c1">Frequ&ecirc;ncia: 22050Hz;</span></li><li class="c8"><span class="c1">Bits per sample: 16;</span></li><li class="c8 c20"><span class="c1">Canais: 1.</span></li></ol><p class="c0"><span class="c1">As informa&ccedil;&otilde;es s&atilde;o calculadas a cada 30 segundos, significando que cada amostra dos resultados acontece nesse intervalo. Os dados variam um pouco a cada amostra, dependendo do tamanho dos frames de v&iacute;deo e de &aacute;udio, mas ficam em torno dos valores apresentados:</span></p><table cellpadding="0" cellspacing="0" class="c27"><tbody><tr class="c14"><td class="c5"><p class="c3"><span class="c13">Aparelho</span></p></td><td class="c30"><p class="c3"><span class="c13">Tipo de medi&ccedil;&atilde;o</span></p></td><td class="c24"><p class="c3"><span class="c13">Tempo total no trecho </span></p></td><td class="c25"><p class="c3"><span class="c13">Numero de medi&ccedil;&otilde;es </span></p></td><td class="c16"><p class="c3"><span class="c13">Frames/s</span></p></td><td class="c21"><p class="c3"><span class="c13">Tempo m&aacute;ximo</span></p></td><td class="c5"><p class="c3"><span class="c13">Tempo m&eacute;dio</span></p></td></tr><tr><td class="c5"><p class="c3"><span class="c13">Motorola Milestone</span></p></td><td class="c30"><p class="c3"><span class="c13">CAPTURA DE VIDEO</span></p></td><td class="c24"><p class="c3"><span class="c13">525.25ms (2% do intervalo)</span></p></td><td class="c25"><p class="c3"><span class="c13">452</span></p></td><td class="c16"><p class="c3"><span class="c13">15</span></p></td><td class="c21"><p class="c3"><span class="c13">3.39ms</span></p></td><td class="c5"><p class="c3"><span class="c13">1.16ms</span></p></td></tr><tr><td class="c5"><p class="c3"><span class="c13">Motorola Milestone</span></p></td><td class="c30"><p class="c3"><span class="c13">CAPTURA DE &Aacute;UDIO</span></p></td><td class="c24"><p class="c3"><span class="c13">41.78ms</span></p></td><td class="c25"><p class="c3"><span class="c13">575</span></p></td><td class="c16"><p class="c3"><span class="c13">19</span></p></td><td class="c21"><p class="c3"><span class="c13">0.98ms</span></p></td><td class="c5"><p class="c3"><span class="c13">0.07ms</span></p></td></tr><tr><td class="c5"><p class="c3"><span class="c13">Samsung Galaxy</span></p></td><td class="c30"><p class="c3"><span class="c13">RENDERIZA&Ccedil;&Atilde;O &nbsp;DE VIDEO</span></p></td><td class="c24"><p class="c3"><span class="c13">1228.83ms (4% do intervalo)</span></p></td><td class="c25"><p class="c3"><span class="c13">426</span></p></td><td class="c16"><p class="c3"><span class="c13">14</span></p></td><td class="c21"><p class="c3"><span class="c13">21.97ms</span></p></td><td class="c5"><p class="c3"><span class="c13"> 2.88ms</span></p></td></tr><tr><td class="c5"><p class="c3"><span class="c13">Samsung Galaxy</span></p></td><td class="c30"><p class="c3"><span class="c13">RENDERIZA&Ccedil;&Atilde;O DE &Aacute;UDIO</span></p></td><td class="c24"><p class="c3"><span class="c13">10573.40ms (35% do intervalo)</span></p></td><td class="c25"><p class="c3"><span class="c13">539</span></p></td><td class="c16"><p class="c3"><span class="c13">18</span></p></td><td class="c21"><p class="c3"><span class="c13">99.35ms</span></p></td><td class="c5"><p class="c3"><span class="c13">19.62ms</span></p></td></tr></tbody></table><p class="c0"><span class="c1">Tabela 2 - Teste 1: Motorola Milestone enviando para Samsung Galaxy</span></p><a href="#" name="id.7irmnt-gn2i7i"></a><p class="c0"><span class="c1 c7">4.2 Teste 2: Transmitindo com o Milestone e recebendo com o Samsung</span></p><p class="c0"><span class="c1">A pr&oacute;xima tabela utiliza os mesmos par&acirc;metros da tabela Teste 1, por&eacute;m agora com o Samsung Galaxy enviando para o Motorola Milestone:</span></p><table cellpadding="0" cellspacing="0" class="c27"><tbody><tr><td class="c10"><p class="c3"><span class="c13">Aparelho</span></p></td><td class="c4"><p class="c3"><span class="c13">Tipo de medi&ccedil;&atilde;o</span></p></td><td class="c28"><p class="c3"><span class="c13">Tempo total no trecho </span></p></td><td class="c34"><p class="c3"><span class="c13">Numero de medi&ccedil;&otilde;es </span></p></td><td class="c32"><p class="c3"><span class="c13">Frames/s</span></p></td><td class="c10"><p class="c3"><span class="c13">Tempo m&aacute;ximo</span></p></td><td class="c10"><p class="c3"><span class="c13">Tempo m&eacute;dio</span></p></td></tr><tr class="c14"><td class="c10"><p class="c3"><span class="c13">Samsung Galaxy</span></p></td><td class="c4"><p class="c3"><span class="c13">CAPTURA DE VIDEO</span></p></td><td class="c28"><p class="c3"><span class="c13">326.23ms (1% do intervalo)</span></p></td><td class="c34"><p class="c3"><span class="c13">451</span></p></td><td class="c32"><p class="c3"><span class="c13">15</span></p></td><td class="c10"><p class="c3"><span class="c13">1.58ms</span></p></td><td class="c10"><p class="c3"><span class="c13">0.72ms</span></p></td></tr><tr class="c14"><td class="c10"><p class="c3"><span class="c13">Samsung Galaxy</span></p></td><td class="c4"><p class="c3"><span class="c13">CAPTURA DE &Aacute;UDIO</span></p></td><td class="c28"><p class="c3"><span class="c13">15.38ms</span></p></td><td class="c34"><p class="c3"><span class="c13">576</span></p></td><td class="c32"><p class="c3"><span class="c13">19</span></p></td><td class="c10"><p class="c3"><span class="c13">0.30ms</span></p></td><td class="c10"><p class="c3"><span class="c13">0.03ms</span></p></td></tr><tr class="c14"><td class="c10"><p class="c3"><span class="c13">Motorola Milestone</span></p></td><td class="c4"><p class="c3"><span class="c13">RENDERIZA&Ccedil;&Atilde;O &nbsp;DE VIDEO</span></p></td><td class="c28"><p class="c3"><span class="c13">7149.21ms (24% do intervalo)</span></p></td><td class="c34"><p class="c3"><span class="c13">446</span></p></td><td class="c32"><p class="c3"><span class="c13">15</span></p></td><td class="c10"><p class="c3"><span class="c13">43.67ms</span></p></td><td class="c10"><p class="c3"><span class="c13">16.03ms</span></p></td></tr><tr class="c14"><td class="c10"><p class="c3"><span class="c13">Motorola Milestone</span></p></td><td class="c4"><p class="c3"><span class="c13">RENDERIZA&Ccedil;&Atilde;O DE &Aacute;UDIO</span></p></td><td class="c28"><p class="c3"><span class="c13">19097.86ms (64% do intervalo)</span></p></td><td class="c34"><p class="c3"><span class="c13">572</span></p></td><td class="c32"><p class="c3"><span class="c13">19</span></p></td><td class="c10"><p class="c3"><span class="c13">113.56ms</span></p></td><td class="c10"><p class="c3"><span class="c13">33.39ms</span></p></td></tr></tbody></table><p class="c0"><span class="c1">Tabela 3 Teste 2: Samsung Galaxy enviando para Motorola Milestone</span></p><a href="#" name="kix.pwxi02-f5u4ay"></a><p class="c0"><span class="c1 c7">4.3 Teste 3: Aumentando a taxa de frames</span></p><p class="c0"><span class="c1">O pr&oacute;ximo teste &eacute; igual ao teste 2, por&eacute;m com a taxa de frames setada para 30/s:</span></p><table cellpadding="0" cellspacing="0" class="c27"><tbody><tr class="c14"><td class="c5"><p class="c3"><span class="c13">Aparelho</span></p></td><td class="c26"><p class="c3"><span class="c13">Tipo de medi&ccedil;&atilde;o</span></p></td><td class="c38"><p class="c3"><span class="c13">Tempo total no trecho </span></p></td><td class="c23"><p class="c3"><span class="c13">Numero de medi&ccedil;&otilde;es </span></p></td><td class="c18"><p class="c3"><span class="c13">Frames/s</span></p></td><td class="c17"><p class="c3"><span class="c13">Tempo m&aacute;ximo</span></p></td><td class="c5"><p class="c3"><span class="c13">Tempo m&eacute;dio</span></p></td></tr><tr class="c14"><td class="c5"><p class="c3"><span class="c13">Samsung Galaxy</span></p></td><td class="c26"><p class="c3"><span class="c13">CAPTURA DE VIDEO</span></p></td><td class="c38"><p class="c3"><span class="c13">519.04ms (2% do intervalo)</span></p></td><td class="c23"><p class="c3"><span class="c13">898</span></p></td><td class="c18"><p class="c3"><span class="c13">30</span></p></td><td class="c17"><p class="c3"><span class="c13">0.88ms</span></p></td><td class="c5"><p class="c3"><span class="c13">0.58ms</span></p></td></tr><tr class="c14"><td class="c5"><p class="c3"><span class="c13">Samsung Galaxy</span></p></td><td class="c26"><p class="c3"><span class="c13">CAPTURA DE &Aacute;UDIO</span></p></td><td class="c38"><p class="c3"><span class="c13">13.97ms</span></p></td><td class="c23"><p class="c3"><span class="c13">577</span></p></td><td class="c18"><p class="c3"><span class="c13">19</span></p></td><td class="c17"><p class="c3"><span class="c13">0.69ms</span></p></td><td class="c5"><p class="c3"><span class="c13">0.02ms</span></p></td></tr><tr class="c14"><td class="c5"><p class="c3"><span class="c13">Motorola Milestone</span></p></td><td class="c26"><p class="c3"><span class="c13">RENDERIZA&Ccedil;&Atilde;O &nbsp;DE VIDEO</span></p></td><td class="c38"><p class="c3"><span class="c13">11254.71ms (38% do intervalo)</span></p></td><td class="c23"><p class="c3"><span class="c13">881</span></p></td><td class="c18"><p class="c3"><span class="c13">29</span></p></td><td class="c17"><p class="c3"><span class="c13">41.41ms</span></p></td><td class="c5"><p class="c3"><span class="c13">12.77ms</span></p></td></tr><tr class="c14"><td class="c5"><p class="c3"><span class="c13">Motorola Milestone</span></p></td><td class="c26"><p class="c3"><span class="c13">RENDERIZA&Ccedil;&Atilde;O DE &Aacute;UDIO</span></p></td><td class="c38"><p class="c3"><span class="c13">13042.82ms (43% do intervalo)</span></p></td><td class="c23"><p class="c3"><span class="c13">538</span></p></td><td class="c18"><p class="c3"><span class="c13">18</span></p></td><td class="c17"><p class="c3"><span class="c13">98.69ms</span></p></td><td class="c5"><p class="c3"><span class="c13">24.24ms</span></p></td></tr></tbody></table><p class="c0"><span class="c1">Tabela 4 Teste 3: Samsung Galaxy enviando para Motorola Milestone a 30fps</span></p><a href="#" name="id.8xnd88-wyry53"></a><p class="c0"><span class="c1 c7">4.4 An&aacute;lise dos resultados dos testes:</span></p><p class="c0"><span class="c1">Pelos 3 testes acima, pode-se perceber que os testes do Samsung transmitindo para o Motorola tiveram melhores resultados que o teste do Motorola transmitindo para o Samsung. O motivo &eacute; que a codifica&ccedil;&atilde;o &eacute; um processo mais pesado que a decodifica&ccedil;&atilde;o, portanto &eacute; na codifica&ccedil;&atilde;o que est&aacute; o ponto cr&iacute;tico de desempenho do aplicativo. Logo, utilizando o Samsung para codificar e o Motorola para decodificar, obt&eacute;m-se um cen&aacute;rio melhor que o oposto, visto que o processador do Samsung &eacute; melhor.</span></p><p class="c0"><span class="c1">N&atilde;o foram testadas muitas varia&ccedil;&otilde;es nos par&acirc;metros de codifica&ccedil;&atilde;o de &aacute;udio/v&iacute;deo. Mesmo assim, os par&acirc;metros utilizados no Teste 1 devem ser pr&oacute;ximos dos par&acirc;metros &oacute;timos considerando o cen&aacute;rio &ldquo;Motorola transmitindo para Samsung&rdquo;. E os par&acirc;metros obtidos no Teste 3 devem ser pr&oacute;ximos dos par&acirc;metros &oacute;timos considerando o cen&aacute;rio inverso.</span></p><p class="c0"><span class="c1">A resolu&ccedil;&atilde;o utilizada em todos os testes foi 320x240. Resolu&ccedil;&otilde;es maiores que essa causaram uma grande queda no desempenho no Motorola, tanto na codifica&ccedil;&atilde;o como na decodifica&ccedil;&atilde;o, mas no Samsung o desempenho se manteve bom. </span></p><p class="c0"><span class="c1">&Eacute; importante ressaltar que o tamanho do v&iacute;deo exibido no celular n&atilde;o &eacute; necessariamente igual &agrave; resolu&ccedil;&atilde;o da codifica&ccedil;&atilde;o, pois o v&iacute;deo pode ser ampliado no momento da exibi&ccedil;&atilde;o com o OpenGL, que, nesse caso, realiza uma interpola&ccedil;&atilde;o dos pixels. Nos 3 testes acima n&atilde;o realizamos essa amplia&ccedil;&atilde;o. Mas nos testes informais que realizamos ela se mostrou bastante eficiente, principalmente no Samsung. No Samsung, que tem OpenGL ES 1.1 (o qual utiliza o hardware para suas tarefas de renderiza&ccedil;&atilde;o) conseguimos ampliar o v&iacute;deo de 320x240 para 800x480 no momento da exibi&ccedil;&atilde;o, quase sem perda de desempenho. No Motorola, que tem OpenGL ES 1.0 (todo em software), tamb&eacute;m foi poss&iacute;vel ampliar o tamanho da exibi&ccedil;&atilde;o, mas para valores n&atilde;o t&atilde;o grandes, sen&atilde;o a queda no desempenho &eacute; vis&iacute;vel.</span></p><p class="c0"><span class="c1">&nbsp;</span></p></body></html>